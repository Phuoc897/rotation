import streamlit as st
import numpy as np
from PIL import Image, ImageFilter, ImageEnhance, ImageDraw
import io
import math

# C·∫•u h√¨nh trang
st.set_page_config(
    page_title="üé® Givens Rotation Image Editor",
    page_icon="üé®",
    layout="wide"
)

# CSS v·ªõi interactive 3D
st.markdown("""
<style>
    .matrix-box {
        background: #f0f2f6;
        border: 1px solid #ddd;
        border-radius: 5px;
        padding: 10px;
        font-family: monospace;
        margin: 10px 0;
    }
    .info-box {
        background: #e8f4fd;
        border-left: 4px solid #4A90E2;
        padding: 10px;
        margin: 10px 0;
    }
    .canvas-container {
        position: relative;
        border: 2px solid #4A90E2;
        border-radius: 10px;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        margin: 10px 0;
    }
    .control-panel {
        background: #f8f9fa;
        border-radius: 8px;
        padding: 15px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .interactive-hint {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-radius: 5px;
        padding: 10px;
        color: #856404;
        margin: 10px 0;
        text-align: center;
    }
</style>
""", unsafe_allow_html=True)

# Header
st.title("üé® Givens Rotation Image Editor")
st.markdown("Ch·ªânh s·ª≠a ·∫£nh v·ªõi ph√©p bi·∫øn ƒë·ªïi Givens Rotation")

# =================== GIVENS ROTATION FUNCTIONS ===================

def givens_2d(theta):
    """T·∫°o ma tr·∫≠n Givens 2D"""
    c = np.cos(theta)
    s = np.sin(theta)
    return np.array([[c, -s], [s, c]])

def givens_3d(theta, axis='z'):
    """T·∫°o ma tr·∫≠n Givens 3D cho tr·ª•c x, y, z"""
    c = np.cos(theta)
    s = np.sin(theta)
    
    if axis == 'x':
        return np.array([[1, 0, 0], [0, c, -s], [0, s, c]])
    elif axis == 'y':
        return np.array([[c, 0, s], [0, 1, 0], [-s, 0, c]])
    else:  # z
        return np.array([[c, -s, 0], [s, c, 0], [0, 0, 1]])

def rotate_image_2d(image, angle_deg):
    """Xoay ·∫£nh 2D b·∫±ng Givens rotation"""
    theta = np.radians(angle_deg)
    c = np.cos(theta)
    s = np.sin(theta)
    
    # T√¢m xoay
    cx, cy = image.width // 2, image.height // 2
    
    # Ma tr·∫≠n affine cho PIL
    a, b = c, s
    c_val, d = -s, c
    e = cx * (1 - c) + cy * s
    f = cy * (1 - c) - cx * s
    
    return image.transform(
        image.size, Image.AFFINE,
        (a, b, c_val, d, e, f),
        resample=Image.BICUBIC,
        fillcolor='white'
    )

def create_3d_mesh(image, depth_scale=30, resolution=40):
    """T·∫°o mesh 3D ƒë∆°n gi·∫£n t·ª´ ·∫£nh"""
    # Resize ·∫£nh
    img_small = image.resize((resolution, resolution))
    img_array = np.array(img_small)
    
    # T·∫°o depth map t·ª´ brightness
    if len(img_array.shape) == 3:
        depth = np.mean(img_array, axis=2)
    else:
        depth = img_array
    
    # Normalize depth
    depth = depth / 255.0 * depth_scale / 100
    
    # T·∫°o vertices
    vertices = []
    colors = []
    faces = []
    
    h, w = depth.shape
    for y in range(h):
        for x in range(w):
            # T·ªça ƒë·ªô 3D
            vertex_x = (x - w/2) / w * 2
            vertex_y = (y - h/2) / h * 2
            vertex_z = depth[y, x]
            
            vertices.append([vertex_x, vertex_y, vertex_z])
            
            # M√†u t·ª´ ·∫£nh
            if len(img_array.shape) == 3:
                colors.append(img_array[y, x] / 255.0)
            else:
                gray = img_array[y, x] / 255.0
                colors.append([gray, gray, gray])
    
    # T·∫°o faces (triangles)
    for y in range(h-1):
        for x in range(w-1):
            # Ch·ªâ s·ªë vertices
            i1 = y * w + x
            i2 = y * w + (x + 1)
            i3 = (y + 1) * w + x
            i4 = (y + 1) * w + (x + 1)
            
            # Hai triangles cho m·ªói quad
            faces.append([i1, i2, i3])
            faces.append([i2, i4, i3])
    
    return np.array(vertices), np.array(colors), np.array(faces), (h, w)

def apply_3d_rotation(vertices, rx, ry, rz):
    """√Åp d·ª•ng rotation 3D"""
    # Chuy·ªÉn sang radian
    rx_rad = np.radians(rx)
    ry_rad = np.radians(ry)
    rz_rad = np.radians(rz)
    
    # T·∫°o ma tr·∫≠n rotation
    Rx = givens_3d(rx_rad, 'x')
    Ry = givens_3d(ry_rad, 'y')
    Rz = givens_3d(rz_rad, 'z')
    
    # K·∫øt h·ª£p rotation (Z * Y * X)
    R = np.dot(Rz, np.dot(Ry, Rx))
    
    # √Åp d·ª•ng rotation
    rotated = np.dot(vertices, R.T)
    
    return rotated, R

def project_3d_to_2d(vertices_3d, distance=3):
    """Chi·∫øu 3D l√™n 2D v·ªõi perspective"""
    projected = []
    z_values = []
    
    for vertex in vertices_3d:
        x, y, z = vertex
        z_cam = z + distance
        if z_cam > 0.1:  # Tr√°nh chia cho 0
            px = x / z_cam
            py = y / z_cam
        else:
            px, py = 0, 0
        projected.append([px, py])
        z_values.append(z_cam)
    
    return np.array(projected), np.array(z_values)

def render_3d_mesh_advanced(vertices_3d, colors, faces, projected_2d, z_values, image_size=600):
    """Render mesh 3D v·ªõi depth sorting v√† wireframe"""
    img = Image.new('RGB', (image_size, image_size), (20, 25, 35))
    draw = ImageDraw.Draw(img)
    
    # Scale t·ªça ƒë·ªô 2D
    proj_scaled = projected_2d.copy()
    proj_scaled[:, 0] = (proj_scaled[:, 0] + 1) * image_size / 2
    proj_scaled[:, 1] = (proj_scaled[:, 1] + 1) * image_size / 2
    
    # Sort faces theo ƒë·ªô s√¢u (z-buffer ƒë∆°n gi·∫£n)
    face_depths = []
    for face in faces:
        avg_z = np.mean([z_values[i] for i in face])
        face_depths.append(avg_z)
    
    # S·∫Øp x·∫øp faces theo ƒë·ªô s√¢u (xa nh·∫•t tr∆∞·ªõc)
    sorted_indices = np.argsort(face_depths)[::-1]
    
    # V·∫Ω faces
    for idx in sorted_indices:
        face = faces[idx]
        if len(face) >= 3:
            # L·∫•y t·ªça ƒë·ªô c·ªßa 3 vertices ƒë·∫ßu
            points = []
            face_colors = []
            valid = True
            
            for i in range(3):
                vertex_idx = face[i]
                if vertex_idx < len(proj_scaled):
                    x, y = proj_scaled[vertex_idx]
                    if 0 <= x < image_size and 0 <= y < image_size:
                        points.append((int(x), int(y)))
                        face_colors.append(colors[vertex_idx])
                    else:
                        valid = False
                        break
                else:
                    valid = False
                    break
            
            if valid and len(points) == 3:
                # T√≠nh m√†u trung b√¨nh
                avg_color = np.mean(face_colors, axis=0)
                # √Åp d·ª•ng shading ƒë∆°n gi·∫£n
                brightness = 0.3 + 0.7 * (face_depths[idx] / max(face_depths) if max(face_depths) > 0 else 1)
                final_color = tuple((avg_color * brightness * 255).astype(int))
                
                # V·∫Ω triangle
                try:
                    draw.polygon(points, fill=final_color, outline=(100, 120, 150))
                except:
                    pass
    
    # V·∫Ω wireframe
    for face in faces:
        if len(face) >= 3:
            points = []
            for i in range(3):
                vertex_idx = face[i]
                if vertex_idx < len(proj_scaled):
                    x, y = proj_scaled[vertex_idx]
                    if 0 <= x < image_size and 0 <= y < image_size:
                        points.append((int(x), int(y)))
            
            if len(points) == 3:
                try:
                    # V·∫Ω wireframe
                    for i in range(3):
                        start = points[i]
                        end = points[(i + 1) % 3]
                        draw.line([start, end], fill=(80, 100, 130), width=1)
                except:
                    pass
    
    return img

def generate_interactive_3d_html(vertices, colors, faces, mesh_size):
    """T·∫°o HTML v·ªõi Three.js cho 3D interactive"""
    
    # Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu sang format JSON
    vertices_js = vertices.tolist()
    colors_js = colors.tolist()
    faces_js = faces.tolist()
    
    html_code = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Interactive 3D Mesh</title>
        <style>
            body {{ margin: 0; overflow: hidden; background: #1a1a2e; }}
            #container {{ width: 100%; height: 500px; }}
            #controls {{ 
                position: absolute; 
                top: 10px; 
                left: 10px; 
                background: rgba(0,0,0,0.7); 
                color: white; 
                padding: 10px; 
                border-radius: 5px;
                font-family: Arial, sans-serif;
                font-size: 12px;
            }}
        </style>
    </head>
    <body>
        <div id="container"></div>
        <div id="controls">
            <div>üñ±Ô∏è K√©o chu·ªôt ƒë·ªÉ xoay</div>
            <div>üîç Cu·ªôn chu·ªôt ƒë·ªÉ zoom</div>
            <div>Vertices: {len(vertices)}</div>
            <div>Faces: {len(faces)}</div>
        </div>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script>
            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / 500, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({{ antialias: true }});
            renderer.setSize(window.innerWidth, 500);
            renderer.setClearColor(0x1a1a2e);
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Create geometry
            const geometry = new THREE.BufferGeometry();
            
            // Vertices
            const vertices = {vertices_js};
            const verticesArray = new Float32Array(vertices.length * 3);
            for(let i = 0; i < vertices.length; i++) {{
                verticesArray[i * 3] = vertices[i][0];
                verticesArray[i * 3 + 1] = vertices[i][1]; 
                verticesArray[i * 3 + 2] = vertices[i][2];
            }}
            geometry.setAttribute('position', new THREE.BufferAttribute(verticesArray, 3));
            
            // Colors
            const colors = {colors_js};
            const colorsArray = new Float32Array(vertices.length * 3);
            for(let i = 0; i < colors.length; i++) {{
                colorsArray[i * 3] = colors[i][0];
                colorsArray[i * 3 + 1] = colors[i][1];
                colorsArray[i * 3 + 2] = colors[i][2];
            }}
            geometry.setAttribute('color', new THREE.BufferAttribute(colorsArray, 3));
            
            // Faces
            const faces = {faces_js};
            const indices = [];
            for(let i = 0; i < faces.length; i++) {{
                indices.push(faces[i][0], faces[i][1], faces[i][2]);
            }}
            geometry.setIndex(indices);
            
            // Compute normals
            geometry.computeVertexNormals();
            
            // Materials
            const material = new THREE.MeshPhongMaterial({{ 
                vertexColors: true,
                side: THREE.DoubleSide,
                shininess: 30
            }});
            
            const wireframeMaterial = new THREE.MeshBasicMaterial({{ 
                color: 0x4a90e2,
                wireframe: true,
                transparent: true,
                opacity: 0.3
            }});
            
            // Meshes
            const mesh = new THREE.Mesh(geometry, material);
            const wireframe = new THREE.Mesh(geometry, wireframeMaterial);
            
            scene.add(mesh);
            scene.add(wireframe);
            
            // Lights
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Camera position
            camera.position.z = 3;
            
            // Mouse controls
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            let currentRotationX = 0;
            let currentRotationY = 0;
            
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('wheel', onWheel, false);
            
            function onMouseDown(event) {{
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            }}
            
            function onMouseMove(event) {{
                if (mouseDown) {{
                    const deltaX = event.clientX - mouseX;
                    const deltaY = event.clientY - mouseY;
                    
                    targetRotationY += deltaX * 0.01;
                    targetRotationX += deltaY * 0.01;
                    
                    mouseX = event.clientX;
                    mouseY = event.clientY;
                }}
            }}
            
            function onMouseUp(event) {{
                mouseDown = false;
            }}
            
            function onWheel(event) {{
                camera.position.z += event.deltaY * 0.01;
                camera.position.z = Math.max(1, Math.min(10, camera.position.z));
            }}
            
            // Animation loop
            function animate() {{
                requestAnimationFrame(animate);
                
                // Smooth rotation
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                mesh.rotation.x = currentRotationX;
                mesh.rotation.y = currentRotationY;
                wireframe.rotation.x = currentRotationX;
                wireframe.rotation.y = currentRotationY;
                
                renderer.render(scene, camera);
            }}
            
            animate();
            
            // Handle resize
            window.addEventListener('resize', function() {{
                camera.aspect = window.innerWidth / 500;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, 500);
            }});
        </script>
    </body>
    </html>
    """
    
    return html_code

# =================== MAIN APP ===================

# Upload file
uploaded_file = st.file_uploader(
    "üìÅ Ch·ªçn ·∫£nh", 
    type=['png', 'jpg', 'jpeg'],
    help="H·ªó tr·ª£ PNG, JPG, JPEG"
)

if uploaded_file:
    # ƒê·ªçc ·∫£nh
    original_image = Image.open(uploaded_file)
    if original_image.mode != 'RGB':
        original_image = original_image.convert('RGB')
    
    # Tabs
    tab1, tab2, tab3, tab4 = st.tabs(["üñºÔ∏è Ch·ªânh s·ª≠a 2D", "üåê Hi·ªáu ·ª©ng 3D", "üéÆ 3D T∆∞∆°ng t√°c", "üìä Ma tr·∫≠n"])
    
    # TAB 1: 2D EDITING
    with tab1:
        st.subheader("üñºÔ∏è Ch·ªânh s·ª≠a 2D v·ªõi Givens Rotation")
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown("**·∫¢nh g·ªëc:**")
            st.image(original_image, use_column_width=True)
        
        # Controls
        st.sidebar.header("üéõÔ∏è Tham s·ªë 2D")
        
        # Basic adjustments
        brightness = st.sidebar.slider("üîÜ ƒê·ªô s√°ng", 0.5, 2.0, 1.0, 0.1)
        contrast = st.sidebar.slider("üåà ƒê·ªô t∆∞∆°ng ph·∫£n", 0.5, 2.0, 1.0, 0.1)
        blur = st.sidebar.slider("üî≤ L√†m m·ªù", 0, 5, 0)
        
        # Givens rotation
        rotation = st.sidebar.slider("üîÑ Givens Rotation (ƒë·ªô)", -180, 180, 0, 15)
        
        # √Åp d·ª•ng ch·ªânh s·ª≠a
        edited_image = original_image.copy()
        
        # Brightness
        if brightness != 1.0:
            enhancer = ImageEnhance.Brightness(edited_image)
            edited_image = enhancer.enhance(brightness)
        
        # Contrast
        if contrast != 1.0:
            enhancer = ImageEnhance.Contrast(edited_image)
            edited_image = enhancer.enhance(contrast)
        
        # Blur
        if blur > 0:
            edited_image = edited_image.filter(ImageFilter.GaussianBlur(blur))
        
        # Givens rotation
        if rotation != 0:
            edited_image = rotate_image_2d(edited_image, rotation)
        
        with col2:
            st.markdown("**·∫¢nh ƒë√£ ch·ªânh s·ª≠a:**")
            st.image(edited_image, use_column_width=True)
        
        # Download
        if edited_image:
            buf = io.BytesIO()
            edited_image.save(buf, format='PNG')
            st.download_button(
                "üíæ T·∫£i xu·ªëng",
                buf.getvalue(),
                f"edited_{uploaded_file.name}",
                "image/png"
            )
    
    # TAB 2: 3D EFFECTS (Static)
    with tab2:
        st.subheader("üåê Hi·ªáu ·ª©ng 3D v·ªõi Givens Rotation")
        
        st.markdown('<div class="control-panel">', unsafe_allow_html=True)
        
        col1, col2, col3 = st.columns(3)
        with col1:
            rx = st.slider("üîÑ Rotation X", -180, 180, 15, 15)
            depth_scale = st.slider("üèîÔ∏è ƒê·ªô s√¢u", 10, 100, 30, 10)
        with col2:
            ry = st.slider("üîÑ Rotation Y", -180, 180, -20, 15)
            resolution = st.slider("üîç ƒê·ªô ph√¢n gi·∫£i", 20, 60, 40, 10)
        with col3:
            rz = st.slider("üîÑ Rotation Z", -180, 180, 0, 15)
            render_mode = st.selectbox("üé® Ch·∫ø ƒë·ªô render", ["Solid", "Wireframe", "Both"])
        
        st.markdown('</div>', unsafe_allow_html=True)
        
        if st.button("üöÄ T·∫°o hi·ªáu ·ª©ng 3D", type="primary"):
            with st.spinner("ƒêang x·ª≠ l√Ω..."):
                # T·∫°o mesh 3D
                vertices, colors, faces, mesh_size = create_3d_mesh(
                    original_image, depth_scale, resolution
                )
                
                # √Åp d·ª•ng rotation
                rotated_vertices, rotation_matrix = apply_3d_rotation(vertices, rx, ry, rz)
                
                # Chi·∫øu l√™n 2D
                projected, z_values = project_3d_to_2d(rotated_vertices)
                
                # Render
                result_3d = render_3d_mesh_advanced(
                    rotated_vertices, colors, faces, projected, z_values
                )
                
                # Hi·ªÉn th·ªã k·∫øt qu·∫£
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("**·∫¢nh g·ªëc:**")
                    st.image(original_image, use_column_width=True)
                
                with col2:
                    st.markdown("**Hi·ªáu ·ª©ng 3D:**")
                    st.image(result_3d, use_column_width=True)
                
                # Download 3D
                buf_3d = io.BytesIO()
                result_3d.save(buf_3d, format='PNG')
                st.download_button(
                    "üíæ T·∫£i xu·ªëng 3D",
                    buf_3d.getvalue(),
                    f"3d_{uploaded_file.name}",
                    "image/png"
                )
                
                # L∆∞u v√†o session state cho tab interactive
                st.session_state['mesh_data'] = {
                    'vertices': vertices,
                    'colors': colors,
                    'faces': faces,
                    'mesh_size': mesh_size
                }
    
    # TAB 3: 3D INTERACTIVE
    with tab3:
        st.subheader("üéÆ 3D T∆∞∆°ng t√°c - K√©o chu·ªôt ƒë·ªÉ xoay")
        
        st.markdown('<div class="interactive-hint">', unsafe_allow_html=True)
        st.markdown("üñ±Ô∏è **H∆∞·ªõng d·∫´n:** K√©o chu·ªôt ƒë·ªÉ xoay, cu·ªôn chu·ªôt ƒë·ªÉ zoom in/out")
        st.markdown('</div>', unsafe_allow_html=True)
        
        # Ki·ªÉm tra xem ƒë√£ c√≥ mesh data ch∆∞a
        if 'mesh_data' not in st.session_state:
            st.info("üìã H√£y t·∫°o mesh 3D ·ªü tab 'üåê Hi·ªáu ·ª©ng 3D' tr∆∞·ªõc!")
            
            # T·∫°o mesh m·∫∑c ƒë·ªãnh v·ªõi ƒë·ªô ph√¢n gi·∫£i th·∫•p
            if st.button("üîß T·∫°o mesh m·∫∑c ƒë·ªãnh"):
                with st.spinner("ƒêang t·∫°o mesh..."):
                    vertices, colors, faces, mesh_size = create_3d_mesh(
                        original_image, 30, 30
                    )
                    st.session_state['mesh_data'] = {
                        'vertices': vertices,
                        'colors': colors,
                        'faces': faces,
                        'mesh_size': mesh_size
                    }
                    st.rerun()
        else:
            # L·∫•y mesh data
            mesh_data = st.session_state['mesh_data']
            
            # T·∫°o HTML interactive
            interactive_html = generate_interactive_3d_html(
                mesh_data['vertices'],
                mesh_data['colors'], 
                mesh_data['faces'],
                mesh_data['mesh_size']
            )
            
            # Hi·ªÉn th·ªã 3D interactive
            st.markdown('<div class="canvas-container">', unsafe_allow_html=True)
            st.components.v1.html(interactive_html, height=500)
            st.markdown('</div>', unsafe_allow_html=True)
            
            # Th√¥ng tin mesh
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                st.metric("üìä Vertices", len(mesh_data['vertices']))
            with col2:
                st.metric("üî∫ Faces", len(mesh_data['faces']))
            with col3:
                st.metric("üìê Resolution", f"{mesh_data['mesh_size'][0]}x{mesh_data['mesh_size'][1]}")
            with col4:
                if st.button("üîÑ Reset mesh"):
                    del st.session_state['mesh_data']
                    st.rerun()
    
    # TAB 4: MATRICES
    with tab4:
        st.subheader("üìä Ma tr·∫≠n & C√¥ng th·ª©c Givens")
        
        st.markdown("### üßÆ Ma tr·∫≠n Givens 2D")
        st.markdown('<div class="matrix-box">', unsafe_allow_html=True)
        st.code("""
G‚ÇÇD(Œ∏) = [cos(Œ∏)  -sin(Œ∏)]
         [sin(Œ∏)   cos(Œ∏)]

T√≠nh ch·∫•t:
‚Ä¢ Tr·ª±c giao: G^T √ó G = I
‚Ä¢ Det(G) = 1
‚Ä¢ G^(-1) = G^T = G(-Œ∏)
        """)
        st.markdown('</div>', unsafe_allow_html=True)
        
        st.markdown("### üåê Ma tr·∫≠n Givens 3D")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.markdown("**Tr·ª•c X:**")
            st.markdown('<div class="matrix-box">', unsafe_allow_html=True)
            st.code("""
Rx(Œ∏) = [1    0       0   ]
        [0  cos(Œ∏) -sin(Œ∏)]
        [0  sin(Œ∏)  cos(Œ∏)]
            """)
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col2:
            st.markdown("**Tr·ª•c Y:**")
            st.markdown('<div class="matrix-box">', unsafe_allow_html=True)
            st.code("""
Ry(Œ∏) = [ cos(Œ∏) 0  sin(Œ∏)]
        [   0    1    0   ]
        [-sin(Œ∏) 0  cos(Œ∏)]
            """)
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col3:
            st.markdown("**Tr·ª•c Z:**")
            st.markdown('<div class="matrix-box">', unsafe_allow_html=True)
            st.code("""
Rz(Œ∏) = [cos(Œ∏) -sin(Œ∏) 0]
        [sin(Œ∏)  cos(Œ∏) 0]
        [  0       0    1]
            """)
            st.markdown('</div>', unsafe_allow_html=True)
        
        # Demo t∆∞∆°ng t√°c
        st.markdown("### üéØ Demo t∆∞∆°ng t√°c")
        demo_angle = st.slider("G√≥c demo", 0, 360, 45, 15)
        demo_matrix = givens_2d(np.radians(demo_angle))
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.markdown('<div class="matrix-box">', unsafe_allow_html=True)
            st.code(f"""
G({demo_angle}¬∞) = [{demo_matrix[0,0]:7.4f}  {demo_matrix[0,1]:7.4f}]
           [{demo_matrix[1,0]:7.4f}  {demo_matrix[1,1]:7.4f}]

Determinant: {np.linalg.det(demo_matrix):.6f}
            """)
            st.markdown('</div>', unsafe_allow_html=True)
        
        with col2:
            # Visualize rotation effect
            st.markdown("**Hi·ªáu ·ª©ng xoay:**")
            # T·∫°o vector test
            test_vector = np.array([1, 0])
            rotated_vector = np.dot(demo_matrix, test_vector)
            
            # Plot ƒë∆°n gi·∫£n
            fig_data = f"""
Vector g·ªëc: ({test_vector[0]:.2f}, {test_vector[1]:.2f})
Vector xoay: ({rotated_vector[0]:.2f}, {rotated_vector[1]:.2f})
G√≥c xoay: {demo_angle}¬∞
            """
            st.text(fig_data)

else:
    # Landing page
    st.markdown("""
    ## üëã Ch√†o m·ª´ng ƒë·∫øn v·ªõi Givens Rotation Image Editor!
    
    ### üéØ T√≠nh nƒÉng m·ªõi:
    
    **üñºÔ∏è Ch·ªânh s·ª≠a 2D:**
    ‚Ä¢ Givens Rotation v·ªõi g√≥c t√πy ch·ªânh
    ‚Ä¢ ƒêi·ªÅu ch·ªânh ƒë·ªô s√°ng, t∆∞∆°ng ph·∫£n
    ‚Ä¢ L√†m m·ªù Gaussian
    
    **üåê Hi·ªáu ·ª©ng 3D:**
    ‚Ä¢ T·∫°o mesh 3D t·ª´ ·∫£nh
    ‚Ä¢ Rotation 3 tr·ª•c v·ªõi Givens
    ‚Ä¢ Depth sorting v√† wireframe
    
    **üéÆ 3D T∆∞∆°ng t√°c:** ‚≠ê **M·ªöI**
    ‚Ä¢ K√©o chu·ªôt ƒë·ªÉ xoay model 3D
    ‚Ä¢ Zoom in/out b·∫±ng scroll
    ‚Ä¢ Render real-time v·ªõi Three.js
    ‚Ä¢ Lighting v√† shading n√¢ng cao
    
    **üìä Ma tr·∫≠n:**
    ‚Ä¢ Hi·ªÉn th·ªã ma tr·∫≠n transformation
    ‚Ä¢ Demo t∆∞∆°ng t√°c
    ‚Ä¢ C√¥ng th·ª©c to√°n h·ªçc
    
    ### üöÄ C√°ch s·ª≠ d·ª•ng:
    1. **Upload ·∫£nh** (PNG, JPG, JPEG)
    2. **Tab 2D:** Ch·ªânh s·ª≠a c∆° b·∫£n v·ªõi Givens rotation
    3. **Tab 3D:** T·∫°o hi·ªáu ·ª©ng 3D static
    4. **Tab T∆∞∆°ng t√°c:** Kh√°m ph√° model 3D v·ªõi chu·ªôt! üñ±Ô∏è
    5. **Tab Ma tr·∫≠n:** T√¨m hi·ªÉu l√Ω thuy·∫øt
    
    ### üéÆ ƒêi·ªÅu khi·ªÉn 3D:
    ‚Ä¢ **K√©o chu·ªôt:** Xoay model theo m·ªçi h∆∞·ªõng
    ‚Ä¢ **Scroll chu·ªôt:** Zoom in/out
    ‚Ä¢ **Real-time rendering** v·ªõi WebGL
    
    **üìÅ H√£y upload ·∫£nh ƒë·ªÉ b·∫Øt ƒë·∫ßu tr·∫£i nghi·ªám 3D t∆∞∆°ng t√°c!**
    """)
    
    # Demo preview
    st.markdown("### üé® Preview t√≠nh nƒÉng:")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.markdown("""
        **2D Rotation**
        - Ma tr·∫≠n Givens 2x2
        - Xoay ·∫£nh m∆∞·ª£t m√†
        - Gi·ªØ nguy√™n ch·∫•t l∆∞·ª£ng
        """)
    
    with col2:
        st.markdown("""
        **3D Mesh**
        - Depth t·ª´ brightness
        - Wireframe + Solid
        - Multiple rotations
        """)
    
    with col3:
        st.markdown("""
        **Interactive 3D** ‚≠ê
        - Mouse controls
        - Real-time WebGL
        - Smooth animations
        """)

# Footer
st.markdown("---")
st.markdown("""
<div style='text-align: center; color: #666;'>
    üé® <strong>Givens Rotation Image Editor v2.0</strong> - Now with Interactive 3D!<br>
    <small>Powered by Three.js & WebGL</small>
</div>
""", unsafe_allow_html=True)
