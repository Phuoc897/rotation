import streamlit as st
import numpy as np
from PIL import Image, ImageDraw, ImageEnhance, ImageFilter
import io
import math

# C·∫•u h√¨nh trang
st.set_page_config(
    page_title="üîÑ Givens Rotation Editor",
    page_icon="üîÑ",
    layout="wide"
)

# CSS styling
st.markdown("""
<style>
    .main-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        padding: 20px;
        border-radius: 10px;
        color: white;
        text-align: center;
        margin-bottom: 20px;
    }
    .control-panel {
        background: #f8f9fa;
        border-radius: 10px;
        padding: 20px;
        margin: 10px 0;
        border: 1px solid #dee2e6;
    }
    .matrix-display {
        background: #1e1e1e;
        color: #00ff41;
        font-family: 'Courier New', monospace;
        padding: 15px;
        border-radius: 8px;
        margin: 10px 0;
        font-size: 12px;
        line-height: 1.4;
    }
</style>
""", unsafe_allow_html=True)

# Header
st.markdown("""
<div class="main-header">
    <h1>üîÑ Givens Rotation Image Editor</h1>
    <p>√Åp d·ª•ng ph√©p bi·∫øn ƒë·ªïi Givens Rotation ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng 3D ch·∫•t l∆∞·ª£ng cao</p>
</div>
""", unsafe_allow_html=True)

# =================== GIVENS ROTATION FUNCTIONS ===================

def givens_rotation_2d(angle_deg):
    """T·∫°o ma tr·∫≠n Givens rotation 2D chu·∫©n"""
    theta = np.radians(angle_deg)
    c = np.cos(theta)
    s = np.sin(theta)
    return np.array([[c, -s], [s, c]], dtype=np.float64)

def givens_rotation_3d(angle_deg, plane='xy'):
    """T·∫°o ma tr·∫≠n Givens rotation 3D cho c√°c m·∫∑t ph·∫≥ng kh√°c nhau"""
    theta = np.radians(angle_deg)
    c = np.cos(theta)
    s = np.sin(theta)
    
    if plane == 'xy':  # Rotation trong m·∫∑t ph·∫≥ng XY (quanh tr·ª•c Z)
        return np.array([
            [c, -s, 0],
            [s,  c, 0],
            [0,  0, 1]
        ], dtype=np.float64)
    elif plane == 'xz':  # Rotation trong m·∫∑t ph·∫≥ng XZ (quanh tr·ª•c Y)
        return np.array([
            [c,  0, s],
            [0,  1, 0],
            [-s, 0, c]
        ], dtype=np.float64)
    elif plane == 'yz':  # Rotation trong m·∫∑t ph·∫≥ng YZ (quanh tr·ª•c X)
        return np.array([
            [1, 0,  0],
            [0, c, -s],
            [0, s,  c]
        ], dtype=np.float64)

def apply_givens_2d_rotation(image, angle):
    """√Åp d·ª•ng Givens rotation 2D tr·ª±c ti·∫øp l√™n ·∫£nh"""
    if angle == 0:
        return image
    
    # S·ª≠ d·ª•ng PIL v·ªõi interpolation cao
    rotated = image.rotate(
        angle,
        resample=Image.BICUBIC,
        expand=True,
        fillcolor=(0, 0, 0, 0) if image.mode == 'RGBA' else (255, 255, 255)
    )
    return rotated

def create_givens_3d_effect(image, xy_angle, xz_angle, yz_angle, brightness=1.0, quality='high'):
    """
    T·∫°o hi·ªáu ·ª©ng 3D b·∫±ng c√°ch √°p d·ª•ng nhi·ªÅu Givens rotations
    S·ª≠ d·ª•ng texture mapping thay v√¨ point cloud ƒë·ªÉ tr√°nh v·ª° ·∫£nh
    """
    
    # ƒêi·ªÅu ch·ªânh ƒë·ªô s√°ng
    if brightness != 1.0:
        enhancer = ImageEnhance.Brightness(image)
        image = enhancer.enhance(brightness)
    
    width, height = image.size
    
    # T·∫°o depth map t·ª´ luminance
    gray_img = image.convert('L')
    depth_map = np.array(gray_img) / 255.0
    
    # Smooth depth map ƒë·ªÉ tr√°nh artifacts
    from scipy import ndimage
    try:
        depth_map = ndimage.gaussian_filter(depth_map, sigma=1.0)
    except:
        # Fallback n·∫øu kh√¥ng c√≥ scipy
        pass
    
    # T·∫°o mesh grid v·ªõi density ph√π h·ª£p
    if quality == 'ultra':
        step = 1
    elif quality == 'high':
        step = 2
    else:
        step = 3
    
    # T·∫°o 3D mesh coordinates
    mesh_points = []
    mesh_colors = []
    
    for y in range(0, height, step):
        for x in range(0, width, step):
            # Normalized coordinates [-1, 1]
            norm_x = (x / width - 0.5) * 2.0
            norm_y = (y / height - 0.5) * 2.0
            norm_z = depth_map[y, x] * 0.5  # Depth d·ª±a tr√™n brightness
            
            mesh_points.append([norm_x, norm_y, norm_z])
            
            # L·∫•y m√†u pixel
            try:
                if image.mode == 'RGB':
                    color = list(image.getpixel((x, y)))
                else:
                    gray_val = image.getpixel((x, y))
                    color = [gray_val, gray_val, gray_val]
                mesh_colors.append(color)
            except:
                mesh_colors.append([128, 128, 128])
    
    mesh_points = np.array(mesh_points)
    
    # √Åp d·ª•ng sequential Givens rotations
    if xy_angle != 0:
        R_xy = givens_rotation_3d(xy_angle, 'xy')
        mesh_points = np.dot(mesh_points, R_xy.T)
    
    if xz_angle != 0:
        R_xz = givens_rotation_3d(xz_angle, 'xz')
        mesh_points = np.dot(mesh_points, R_xz.T)
    
    if yz_angle != 0:
        R_yz = givens_rotation_3d(yz_angle, 'yz')
        mesh_points = np.dot(mesh_points, R_yz.T)
    
    # Render v·ªõi texture mapping
    return render_textured_mesh(mesh_points, mesh_colors, width, height, step)

def render_textured_mesh(vertices, colors, width, height, step):
    """Render 3D mesh v·ªõi texture mapping ƒë·ªÉ tr√°nh v·ª° ·∫£nh"""
    
    # Perspective projection v·ªõi FOV ph√π h·ª£p
    fov = 50  # Field of view degrees
    distance = 3.0
    
    projected_points = []
    
    for i, vertex in enumerate(vertices):
        x, y, z = vertex
        z_cam = z + distance
        
        if z_cam > 0.1:
            # Perspective projection
            px = x / z_cam * math.tan(math.radians(fov/2))
            py = y / z_cam * math.tan(math.radians(fov/2))
        else:
            px, py = x * 0.5, y * 0.5
        
        # Convert to screen coordinates v·ªõi margin
        margin = 0.1
        screen_x = int((px + 1) * width * (0.5 - margin) + width * margin)
        screen_y = int((1 - py) * height * (0.5 - margin) + height * margin)
        
        projected_points.append((screen_x, screen_y, colors[i], z_cam))
    
    # Sort by depth (back to front)
    projected_points.sort(key=lambda p: p[3], reverse=True)
    
    # Create result image v·ªõi gradient background
    result_img = create_gradient_background(width, height)
    
    # Render points v·ªõi adaptive sizing
    for screen_x, screen_y, color, depth in projected_points:
        if 0 <= screen_x < width and 0 <= screen_y < height:
            # Adaptive point size based on depth
            base_size = max(step, 2)
            depth_factor = max(0.3, min(1.5, distance / (depth + 0.1)))
            point_size = int(base_size * depth_factor)
            
            # Render v·ªõi anti-aliasing
            render_smooth_point(result_img, screen_x, screen_y, point_size, color)
    
    return result_img

def create_gradient_background(width, height):
    """T·∫°o background gradient ƒë·∫πp"""
    img = Image.new('RGB', (width, height))
    draw = ImageDraw.Draw(img)
    
    # Radial gradient t·ª´ center
    center_x, center_y = width // 2, height // 2
    max_radius = math.sqrt(center_x**2 + center_y**2)
    
    for y in range(height):
        for x in range(width):
            distance = math.sqrt((x - center_x)**2 + (y - center_y)**2)
            factor = 1.0 - (distance / max_radius) * 0.5
            
            r = int(20 * factor)
            g = int(30 * factor)
            b = int(50 * factor)
            
            draw.point([x, y], fill=(r, g, b))
    
    return img

def render_smooth_point(img, x, y, size, color):
    """Render point v·ªõi smooth anti-aliasing"""
    draw = ImageDraw.Draw(img)
    
    if size <= 1:
        draw.point([x, y], fill=tuple(color))
        return
    
    # Multi-layer rendering cho smooth effect
    layers = max(2, size // 2)
    
    for i in range(layers, 0, -1):
        layer_size = int(size * i / layers)
        alpha = (i / layers) * 0.8 + 0.2
        
        # Blend v·ªõi background
        try:
            bg_color = img.getpixel((x, y))
            blended_color = [
                int(bg_color[j] * (1 - alpha) + color[j] * alpha)
                for j in range(3)
            ]
        except:
            blended_color = color
        
        draw.ellipse([
            x - layer_size, y - layer_size,
            x + layer_size, y + layer_size
        ], fill=tuple(blended_color))

# =================== STREAMLIT UI ===================

# Sidebar cho th√¥ng tin
with st.sidebar:
    st.markdown("### üìö Givens Rotation")
    st.markdown("""
    **Givens rotation** l√† ph√©p bi·∫øn ƒë·ªïi orthogonal 
    d√πng ƒë·ªÉ xoay vector trong kh√¥ng gian 2D/3D.
    
    **Ma tr·∫≠n 2D:**
    ```
    [cos Œ∏  -sin Œ∏]
    [sin Œ∏   cos Œ∏]
    ```
    
    **∆Øu ƒëi·ªÉm:**
    - B·∫£o to√†n ƒë·ªô d√†i vector
    - Stable numerically  
    - Composition t·ªët
    """)

# Upload ·∫£nh
uploaded_file = st.file_uploader(
    "üìÅ Ch·ªçn ·∫£nh ƒë·ªÉ √°p d·ª•ng Givens Rotation", 
    type=['png', 'jpg', 'jpeg'],
    help="H·ªó tr·ª£ PNG, JPG, JPEG"
)

if uploaded_file is not None:
    # Load v√† resize ·∫£nh
    image = Image.open(uploaded_file)
    
    # Auto resize ƒë·ªÉ t·ªëi ∆∞u hi·ªáu su·∫•t
    max_size = 600
    if max(image.size) > max_size:
        ratio = max_size / max(image.size)
        new_size = (int(image.width * ratio), int(image.height * ratio))
        image = image.resize(new_size, Image.Resampling.LANCZOS)
    
    col1, col2 = st.columns([1, 2])
    
    with col1:
        st.markdown('<div class="control-panel">', unsafe_allow_html=True)
        st.subheader("üéõÔ∏è Givens Controls")
        
        # Quality setting
        quality = st.selectbox(
            "üéØ Ch·∫•t l∆∞·ª£ng",
            ['normal', 'high', 'ultra'],
            index=1,
            help="Ultra: Ch·∫•t l∆∞·ª£ng t·ªët nh·∫•t nh∆∞ng ch·∫≠m h∆°n"
        )
        
        # Brightness
        brightness = st.slider(
            "üí° ƒê·ªô s√°ng", 0.3, 2.0, 1.0, 0.1,
            help="·∫¢nh h∆∞·ªüng ƒë·∫øn depth map 3D"
        )
        
        st.markdown("### üîÑ Givens Rotations")
        
        # 2D Rotation
        rotation_2d = st.slider(
            "üîÑ 2D Rotation", -180, 180, 0, 5,
            help="Givens rotation 2D c∆° b·∫£n"
        )
        
        # 3D Rotations
        st.markdown("**3D Rotations:**")
        xy_rotation = st.slider(
            "üîÑ XY Plane", -90, 90, 0, 5,
            help="Rotation trong m·∫∑t ph·∫≥ng XY"
        )
        
        xz_rotation = st.slider(
            "üîÑ XZ Plane", -90, 90, 0, 5,
            help="Rotation trong m·∫∑t ph·∫≥ng XZ"
        )
        
        yz_rotation = st.slider(
            "üîÑ YZ Plane", -90, 90, 0, 5,
            help="Rotation trong m·∫∑t ph·∫≥ng YZ"
        )
        
        # Matrix display
        if xy_rotation != 0 or xz_rotation != 0 or yz_rotation != 0:
            st.markdown("### üìä Ma tr·∫≠n hi·ªán t·∫°i")
            
            if xy_rotation != 0:
                R_xy = givens_rotation_3d(xy_rotation, 'xy')
                st.markdown('<div class="matrix-display">', unsafe_allow_html=True)
                st.code(f"XY Rotation Matrix:\n{np.array2string(R_xy, precision=3)}")
                st.markdown('</div>', unsafe_allow_html=True)
        
        # Reset button
        if st.button("üîÑ Reset All"):
            st.rerun()
        
        st.markdown('</div>', unsafe_allow_html=True)
    
    with col2:
        col2_1, col2_2 = st.columns(2)
        
        with col2_1:
            st.subheader("üì∑ ·∫¢nh g·ªëc")
            st.image(image, use_column_width=True)
        
        with col2_2:
            st.subheader("‚ú® Givens Transform")
            
            # Ki·ªÉm tra c√≥ transformation n√†o kh√¥ng
            has_2d = rotation_2d != 0
            has_3d = xy_rotation != 0 or xz_rotation != 0 or yz_rotation != 0
            has_brightness = brightness != 1.0
            
            if has_2d or has_3d or has_brightness:
                with st.spinner("üîÑ Applying Givens Rotations..."):
                    
                    # √Åp d·ª•ng 2D rotation tr∆∞·ªõc (n·∫øu c√≥)
                    if has_2d:
                        result_image = apply_givens_2d_rotation(image, rotation_2d)
                    else:
                        result_image = image
                    
                    # √Åp d·ª•ng 3D effect (n·∫øu c√≥)
                    if has_3d or has_brightness:
                        result_image = create_givens_3d_effect(
                            result_image, xy_rotation, xz_rotation, yz_rotation, 
                            brightness, quality
                        )
                    
                    st.image(result_image, use_column_width=True)
                    
                    # Download button
                    img_buffer = io.BytesIO()
                    result_image.save(img_buffer, format='PNG')
                    
                    st.download_button(
                        label="üíæ Download Result",
                        data=img_buffer.getvalue(),
                        file_name="givens_rotation_result.png",
                        mime="image/png"
                    )
            else:
                st.image(image, use_column_width=True)
                st.info("üëÜ ƒêi·ªÅu ch·ªânh c√°c slider ƒë·ªÉ xem Givens transformations")
        
        # Th√¥ng tin chi ti·∫øt
        st.markdown("---")
        with st.expander("üìñ Gi·∫£i th√≠ch Givens Rotation"):
            st.markdown("""
            **Givens Rotation** l√† m·ªôt ph∆∞∆°ng ph√°p to√°n h·ªçc ƒë·ªÉ th·ª±c hi·ªán ph√©p xoay:
            
            üîÑ **2D Rotation**: Xoay ·∫£nh trong m·∫∑t ph·∫≥ng 2D c∆° b·∫£n
            
            üîÑ **3D Rotations**:
            - **XY Plane**: Rotation quanh tr·ª•c Z (xoay trong m·∫∑t ph·∫≥ng XY)
            - **XZ Plane**: Rotation quanh tr·ª•c Y (xoay trong m·∫∑t ph·∫≥ng XZ)  
            - **YZ Plane**: Rotation quanh tr·ª•c X (xoay trong m·∫∑t ph·∫≥ng YZ)
            
            üí° **ƒê·ªô s√°ng**: ·∫¢nh h∆∞·ªüng ƒë·∫øn depth map ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng 3D
            
            ‚ö° **Ch·∫•t l∆∞·ª£ng**: Ultra mode s·∫Ω gi·ªØ ƒë∆∞·ª£c nhi·ªÅu detail h∆°n nh∆∞ng x·ª≠ l√Ω l√¢u h∆°n
            """)

else:
    st.info("üëÜ Upload m·ªôt ·∫£nh ƒë·ªÉ b·∫Øt ƒë·∫ßu √°p d·ª•ng Givens Rotations!")
    
    # Info v·ªÅ Givens Rotation
    st.markdown("---")
    st.markdown("""
    ### üéì V·ªÅ Givens Rotation
    
    **Givens rotation** l√† m·ªôt k·ªπ thu·∫≠t to√°n h·ªçc quan tr·ªçng trong:
    - Linear algebra v√† matrix decomposition
    - Computer graphics v√† 3D transformations  
    - Signal processing v√† image processing
    - Numerical methods v√† scientific computing
    
    App n√†y demonstrate vi·ªác √°p d·ª•ng Givens rotations ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng 3D cho ·∫£nh!
    """)
